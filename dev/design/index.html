<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Build your own AD · Yota</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Yota</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Main</a></li><li><a class="tocitem" href="../cookbook/">Cookbook</a></li><li class="is-active"><a class="tocitem" href>Build your own AD</a><ul class="internal"><li><a class="tocitem" href="#Theory"><span>Theory</span></a></li><li><a class="tocitem" href="#Practice"><span>Practice</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Build your own AD</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Build your own AD</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dfdx/Yota.jl/blob/main/docs/src/design.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Build-your-own-AD"><a class="docs-heading-anchor" href="#Build-your-own-AD">Build your own AD</a><a id="Build-your-own-AD-1"></a><a class="docs-heading-anchor-permalink" href="#Build-your-own-AD" title="Permalink"></a></h1><p>The design of Yota is pretty simple, and the core of the package can be easily reproduced. In this section we discuss some of the key points in Yota implementation by creating a new AD system from scratch.</p><h2 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h2><p>Automatic differentiation is based on two things:</p><ul><li>set of &quot;primivitve&quot; functions such as <code>+</code>, <code>sin</code>, <code>sqrt</code>, etc. with known symbolic derivatives</li><li><a href="https://en.wikipedia.org/wiki/Chain_rule">chain rule</a> that describes how to combine them together to obtain the derivative of a complex function</li></ul><p>Reverse-mode AD works in two steps:</p><ol><li>Forward pass, i.e. going from inputs to outputs and evaluating primitives in order.</li><li>Reverse pass, i.e. going from outputs to inputs and evaluating derivatives.</li></ol><p>The reverse pass always starts with a &quot;seed&quot; - a derivative of the output variable w.r.t. itself (and thus equal to <code>1</code>). <a href="https://stats.stackexchange.com/a/235758/3305">This answer</a> provides a complete step-by-step example of a (manual) reverse-mode differentiation for scalars.</p><p>While derivatives of scalar-valued functions w.r.t. scalar inputs are also scalars (i.e. have the same &quot;size&quot;), derivative of a vector-valued function <code>f: Rⁿ → Rᵐ</code> w.r.t. a vector input is called Jacobian and has size <code>Rⁿ × Rᵐ</code>. For large inputs and outputs it&#39;s a pretty huge matrix, so in practice it&#39;s never calculated as is. Instead, so-called vector-jacobian product (VJP) is used to propagate gradients to function inputs. For example:</p><pre><code class="nohighlight hljs">x = ...        # input
y = f(x)       # both - x and y - are vectors
z = g(y)       # output variabel, must be scalar

dz/dz = 1               # seed
dz/dy = vjp_g(dz/dz)
dz/dx = vjp_f(dz/dy)</code></pre><p>Here <code>vjp_f()</code> essentially calculates <code>dz/dy * J_f</code>, but more efficiently.</p><p>Sometimes forward and reverse pass share a piece of computation. In this case forward and backward pass can be combined into a single function, returning:</p><ul><li>primal value, i.e. output <code>y</code> of the function <code>f(x)</code></li><li>pullback function that takes the gradient w.r.t. to the function output (<code>dz/dy</code>) and returns gradients w.r.t. its arguments (<code>dz/dx</code>)</li></ul><p>See <a href="https://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html#vector-jacobian-products-vjps-aka-reverse-mode-autodiff">JAX docs</a> for a mathematically robust explanation of VJP and pullbacks.</p><h2 id="Practice"><a class="docs-heading-anchor" href="#Practice">Practice</a><a id="Practice-1"></a><a class="docs-heading-anchor-permalink" href="#Practice" title="Permalink"></a></h2><p>Yota uses two packages under the hood:</p><ul><li><a href="https://github.com/dfdx/Umlaut.jl">Umlaut</a> - code tracer that records execution as a list of primitive calls (<code>Tape</code>)</li><li><a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules</a> - collection of VJP rules (<code>rrule</code>)</li></ul><p>The idea is pretty simple. To differentiate a function call <code>f(args...)</code> we:</p><ol><li>Recursively trace function execution to obtain a tape with only primitives.</li><li>Replace all primitive calls <code>y = g(xs...)</code> with <code>y, pb = rrule(g, xs....)</code>.</li><li>Add the seed to the tape.</li><li>Go backwards, at each step invoking pullbacks to propagate function output gradient to its arguments, i.e. <code>dxs = pb(dy)</code>.</li></ol><p>We will use the following simple function as an example:</p><pre><code class="language-julia hljs">g(a, b) = a * b
h(a) = sin(a)

f(x1, x2) = g(x1, x2) + h(x1)
args = (2.0, 3.0)</code></pre><h3 id="Trace-the-function"><a class="docs-heading-anchor" href="#Trace-the-function">Trace the function</a><a id="Trace-the-function-1"></a><a class="docs-heading-anchor-permalink" href="#Trace-the-function" title="Permalink"></a></h3><p>First of all, we need to let Umlaut know what functions to treat as primitives. By default, Umlaut records everything in Julia&#39;s built-in modules such as <code>Base</code> and <code>Core</code>, but we also want to record functions for which <code>rrule</code> is defined. To do so, we need to create a new tracing context and overload <code>Umlaut.isprimitive</code> method for it:</p><pre><code class="language-julia hljs">using Umlaut
using ChainRules: rrule

struct GradCtx
    pullbacks::Dict{Variable,Variable}    # ignore for now
    derivs::Dict{Variable,Variable}       # ignore for now
end
GradCtx() = GradCtx(Dict(), Dict())

function Umlaut.isprimitive(::GradCtx, f, args...)
    Ts = [a isa DataType ? Type{a} : typeof(a) for a in (f, args...)]
    # return type of rrule(f, args...) will be nothing only if there&#39;s no
    # rrule for this function signature
    if Core.Compiler.return_type(rrule, Ts) !== Nothing
        return true
    else
        return false
    end
end</code></pre><p>Now we can check if the function call is traced correctly:</p><pre><code class="language-julia hljs">val, tape = trace(f, args...; ctx=GradCtx())

# output
(6.909297426825682, Tape{GradCtx}
  inp %1::typeof(f)
  inp %2::Float64
  inp %3::Float64
  %4 = *(%2, %3)::Float64
  %5 = sin(%2)::Float64
  %6 = +(%4, %5)::Float64
)</code></pre><p>Woohoo! Despite nested calls to <code>h()</code> and <code>g()</code>, Umlaut correctly recorded only primirives to the tape.</p><h3 id="Replace-f(args...)-with-rrule(f,-args...)"><a class="docs-heading-anchor" href="#Replace-f(args...)-with-rrule(f,-args...)">Replace f(args...) with rrule(f, args...)</a><a id="Replace-f(args...)-with-rrule(f,-args...)-1"></a><a class="docs-heading-anchor-permalink" href="#Replace-f(args...)-with-rrule(f,-args...)" title="Permalink"></a></h3><p>Umlaut has a function <code>replace!()</code> that can do the replacement. But in this case we will calculate both <code>f(args...)</code> and <code>rrule(f, args...)</code>, which is a double work. Instead we will do a slightly better thing and implement the replacement right during the tracing. To do so, we need to overload <code>Umlaut.record_primitive!()</code> as follows:</p><pre><code class="language-julia hljs">const V = Umlaut.Variable

&quot;&quot;&quot;
    record_primitive!(tape::Tape{GradCtx}, v_fargs...)

Replace ChainRules primitives `f(args...)` with a sequence:

    rr = push!(tape, mkcall(rrule, f, args...))   # i.e. rrule(f, args...)
    val = push!(tape, mkcall(getfield, rr, 1)     # extract value
    pb = push!(tape, mkcall(getfield, rr, 2)      # extract pullback
&quot;&quot;&quot;
function Umlaut.record_primitive!(tape::Tape{GradCtx}, v_fargs...)
    # v_xxx refer to instances of Umlaut.Variable or constants
    # e.g. v_fargs = [+, V(1), 2.0]
    v_f, v_args... = v_fargs
    # fargs are actial values of a function and arguments
    f, args... = [v isa V ? tape[v].val : v for v in v_fargs]
    # record rrule(v_f, v_args...)
    v_rr = push!(tape, mkcall(rrule, v_f, v_args...))
    # get the output and the pullback as separate operations on the tape
    v_val = push!(tape, mkcall(getfield, v_rr, 1))
    v_pb = push!(tape, mkcall(getfield, v_rr, 2))
    # store the mapping from the value var to pullback var
    # in the tape&#39;s context
    tape.c.pullbacks[v_val] = v_pb
    # return value var, the same as if we recorded just f(args...)
    return v_val
end</code></pre><p>Just as the docstring explains it, for each primitive call <code>f(args...)</code> instead of recording it directly we record a sequence of three calls - one for <code>rrule(f, args...)</code> and two to destructure its result. We also save the mapping <code>value -&gt; pullback</code> to the <code>GradCtx.pullbacks</code> field, which we prudently added to the context object.</p><p>Let&#39;s see what we get now:</p><pre><code class="language-julia hljs">val, tape = trace(f, args...; ctx=GradCtx())

# output
(6.909297426825682, Tape{GradCtx}
  inp %1::typeof(f)
  inp %2::Float64
  inp %3::Float64
  %4 = rrule(*, %2, %3)::Tuple{Float64, ChainRules.var&quot;#times_pullback2#1214&quot;{Float64, Float64}}
  %5 = getfield(%4, 1)::Float64
  %6 = getfield(%4, 2)::ChainRules.var&quot;#times_pullback2#1214&quot;{Float64, Float64}
  %7 = rrule(sin, %2)::Tuple{Float64, ChainRules.var&quot;#sin_pullback#1175&quot;{Float64}}
  %8 = getfield(%7, 1)::Float64
  %9 = getfield(%7, 2)::ChainRules.var&quot;#sin_pullback#1175&quot;{Float64}
  %10 = rrule(+, %5, %8)::Tuple{Float64, ChainRules.var&quot;#+_pullback#1203&quot;{Bool, Bool, ChainRulesCore.ProjectTo{Float64, NamedTuple{(), Tuple{}}}, ChainRulesCore.ProjectTo{Float64, NamedTuple{(), Tuple{}}}}}
  %11 = getfield(%10, 1)::Float64
  %12 = getfield(%10, 2)::ChainRules.var&quot;#+_pullback#1203&quot;{Bool, Bool, ChainRulesCore.ProjectTo{Float64, NamedTuple{(), Tuple{}}}, ChainRulesCore.ProjectTo{Float64, NamedTuple{(), Tuple{}}}}
)</code></pre><p>That&#39;s pretty verbose. Let&#39;s make it bit more readable:</p><pre><code class="language-julia hljs">Umlaut.show_format!(:compact)   # switch back with Umlaut.show_format!(:plain)

println(tape)

# output
Tape{GradCtx}
  inp %1::typeof(f)
  inp %2::Float64
  inp %3::Float64
  %5, %6 = [%4] = rrule(*, %2, %3)
  %8, %9 = [%7] = rrule(sin, %2)
  %11, %12 = [%10] = rrule(+, %5, %8)</code></pre><h3 id="Add-seed-to-the-tape"><a class="docs-heading-anchor" href="#Add-seed-to-the-tape">Add seed to the tape</a><a id="Add-seed-to-the-tape-1"></a><a class="docs-heading-anchor-permalink" href="#Add-seed-to-the-tape" title="Permalink"></a></h3><p>As discussed earlier, seed is the derivative of the ouput variable w.r.t. itself, which is 1. We can record this constant to the tape as follows:</p><pre><code class="language-julia hljs">dy = push!(tape, Constant(1))</code></pre><p>We also hold mapping from a (primal) variable on the tape to its derivative variable in the <code>GradCtx.derivs</code> field. The very first pair we must add is from the tape result to the seed:</p><pre><code class="language-julia hljs">tape.c.derivs[tape.result] = dy</code></pre><h3 id="Go-backwards,-propagate-derivatives"><a class="docs-heading-anchor" href="#Go-backwards,-propagate-derivatives">Go backwards, propagate derivatives</a><a id="Go-backwards,-propagate-derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Go-backwards,-propagate-derivatives" title="Permalink"></a></h3><p>During the reverse pass we go backwards from the tape result variable (<code>%11</code> in our case) to its inputs, at each step calling the pullback and updating the derivatives of a function arguments:</p><pre><code class="language-julia hljs"># y is the output variable of the current Call operation
# i.e. we assume call `y = fn(xs...)`
function step_back!(tape::Tape, y::Variable)
    # dy - output of the tape result w.r.t. y
    dy = tape.c.derivs[y]
    # extract pullback for y
    pb = tape.c.pullbacks[y]
    # record a call pb(dy)
    dxs = push!(tape, mkcall(pb, dy))
    # we don&#39;t actually need to go through call to `rrule` itself
    # instead we propage derivs to original f(args...)
    rr = tape[y].args[1]
    y_fargs = tape[rr].args
    # for each argument in f(args...) (including `f` itself)
    for (i, x) in enumerate(y_fargs)
        # if it&#39;s not a constant
        if x isa V
            # set the derivative var as getfield(xs, i)
            dx = push!(tape, mkcall(getfield, dxs, i))
            # WARNING: this is simplified version,
            # won&#39;t work for multipath derivatives!
            tape.c.derivs[bound(tape, x)] = bound(tape, dx)
        end
    end
end</code></pre><p>Say, we are analyzing the last function call - <code>%11, %12 = [%10] = rrule(+, %5, %8)</code>:</p><ul><li><code>y</code> points to <code>%11</code></li><li><code>dy</code> points to our seed - <code>%13</code></li><li>the pullback <code>pb</code> is stored in <code>%12</code></li><li>we record <code>dxs = pb(dy)</code></li><li>and update derivatives for each argument in the original call <code>+(%5, %8)</code></li></ul><p>Note that bold warning at the end: for illustrative purposes we <em>set</em> the mapping from the variable to its derivative, but in practice the same variable may influence the result in more than one way (e.g. <code>x1</code> influences the result via both - <code>g()</code> and <code>h()</code>), and thus we need to <em>set or add</em> to the derivative. Let&#39;s fix it:</p><pre><code class="language-julia hljs">import ChainRules: Tangent


getderiv(tape::Tape, v::Variable) = get(tape.c.derivs, bound(tape, v), nothing)
setderiv!(tape::Tape, x::Variable, dx::Variable) = (
    tape.c.derivs[bound(tape, x)] = bound(tape, dx)
)
hasderiv(tape::Tape, v::Variable) = getderiv(tape, v) !== nothing


function set_or_add_deriv!(tape::Tape, x::Variable, dx::Variable)
    if !hasderiv(tape, x)
        setderiv!(tape, x, dx)
    else
        old_dx = getderiv(tape, x)
        if tape[dx].val isa Tangent || tape[old_dx].val isa Tangent
            new_dx = push!(tape, mkcall(+, dx, old_dx))
        else
            new_dx = push!(tape, mkcall(broadcast, +, dx, old_dx))
        end
        setderiv!(tape, x, new_dx)
    end
end


function step_back!(tape::Tape, y::Variable)
    dy = tape.c.derivs[y]
    pb = tape.c.pullbacks[y]
    dxs = push!(tape, mkcall(pb, dy))
    rr = tape[y].args[1]
    y_fargs = tape[rr].args
    for (i, x) in enumerate(y_fargs)
        if x isa V
            dx = push!(tape, mkcall(getfield, dxs, i))
            # this line has changed
            set_or_add_deriv!(tape, x, dx)
        end
    end
end</code></pre><p>The backward pass itself is simple:</p><pre><code class="language-julia hljs">function back!(tape::Tape; seed=1)
    # z - final variable (usually a loss)
    # y - resulting variable of current op
    # x - dependencies of y
    # dy - derivative of z w.r.t. y
    z = tape.result
    # set seed and the first derivative
    dy = push!(tape, Constant(seed))
    tape.c.derivs[z] = dy
    # the reverse pass, literally
    for i=length(tape)-1:-1:1
        y = bound(tape, V(i))
        op = tape[y]
        # note: skipping rrule() and pullbacks
        if op isa Call &amp;&amp; op.fn != rrule &amp;&amp; !in(y, values(tape.c.pullbacks))
            step_back!(tape, y)
        end
    end
end

back!(tape)

tape.c.derivs

# output
Dict{Variable, Variable} with 5 entries:
  %8  =&gt; %16
  %3  =&gt; %21
  %2  =&gt; %20
  %5  =&gt; %15
  %11 =&gt; %13</code></pre><p><code>tape.c.derivs</code> now contains a map from all primal variables to their derivative variables. These include derivatives w.r.t. function inputs <code>%2</code> and <code>%3</code>. For example:</p><pre><code class="language-julia hljs"># bound variables for function inputs
_, x1, x2 = inputs(tape)

# derivaitves w.r.t. these inputs
dx1 = tape.c.derivs[x1]
dx2 = tape.c.derivs[x2]

# values of these derivatives
tape[dx1].val
tape[dx2].val</code></pre><p>Finally, let&#39;s add a bit of post-processing and wrap it up into a single convenient function:</p><pre><code class="language-julia hljs">import ChainRules: ZeroTangent, unthunk


function grad(f, args...)
    _, tape = trace(f, args...; ctx=GradCtx())
    back!(tape)
    # add a tuple of (val, (gradients...))
    deriv_vars = [hasderiv(tape, v) ? getderiv(tape, v) : ZeroTangent() for v in inputs(tape)]
    deriv_tuple = push!(tape, mkcall(tuple, deriv_vars...))
    # unthunk results
    deriv_tuple_unthunked = push!(tape, mkcall(map, unthunk, deriv_tuple))
    new_result = push!(tape, mkcall(tuple, tape.result, deriv_tuple_unthunked))
    # set result
    tape.result = new_result
    return tape[tape.result].val
end

grad(f, 2.0, 3.0)   # (6.909297426825682, (ZeroTangent(), 2.5838531634528574, 2.0))

# verify using numerical differentiation
import Yota.ngradient

ngradient(f, 2.0, 3.0)  # (2.583853163452614, 2.0000000000001696)</code></pre><p>And we are done!</p><h3 id="What&#39;s-not-covered"><a class="docs-heading-anchor" href="#What&#39;s-not-covered">What&#39;s not covered</a><a id="What&#39;s-not-covered-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-not-covered" title="Permalink"></a></h3><p>Although the code above is a valid AD system suitable for most functions, it doesn&#39;t cover many corner cases, including:</p><ul><li>functions with keyword arguments</li><li>non-differentiable paths</li><li>object constructors</li><li>some (often purposely) missing <a href="https://github.com/dfdx/Yota.jl/blob/0103f6883df49b8bed256deaea41a0a0b65b0a2d/src/rulesets.jl"><code>rrule</code>s</a></li><li>custom seeds</li><li>tape caching, etc.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../cookbook/">« Cookbook</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 3 October 2022 10:13">Monday 3 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
